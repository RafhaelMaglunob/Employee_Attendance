-- Connect as postgres
-- psql -U postgres
-- CREATE DATABASE employee_attendance;
-- \c employee_attendance

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Drop tables in reverse dependency order
DROP TABLE IF EXISTS users_archive CASCADE;
DROP TABLE IF EXISTS users CASCADE;
DROP TABLE IF EXISTS incident_reports_archive CASCADE;
DROP TABLE IF EXISTS incident_reports CASCADE;
DROP TABLE IF EXISTS employee_attendance_archive CASCADE;
DROP TABLE IF EXISTS employee_attendance CASCADE;
DROP TABLE IF EXISTS employee_documents_archive CASCADE;
DROP TABLE IF EXISTS employee_documents CASCADE;
DROP TABLE IF EXISTS employee_dependents_archive CASCADE;
DROP TABLE IF EXISTS employee_dependents CASCADE;
DROP TABLE IF EXISTS employee_contracts_archive CASCADE;
DROP TABLE IF EXISTS employee_contracts CASCADE;
DROP TABLE IF EXISTS leave_requests_archive CASCADE;
DROP TABLE IF EXISTS leave_requests CASCADE;
DROP TABLE IF EXISTS overtime_requests_archive CASCADE;
DROP TABLE IF EXISTS overtime_requests CASCADE;
DROP TABLE IF EXISTS employee_notifications CASCADE;
DROP TABLE IF EXISTS employee_schedule CASCADE;
DROP TABLE IF EXISTS employees_archive CASCADE;
DROP TABLE IF EXISTS employees CASCADE;
DROP TABLE IF EXISTS employee_registry CASCADE;
DROP TABLE IF EXISTS employee_deletion_schedule;
DROP SEQUENCE IF EXISTS employee_id_seq;

-- Sequence for employee IDs
CREATE SEQUENCE employee_id_seq START 1;

-- Employee Registry
CREATE TABLE employee_registry (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    fullname TEXT UNIQUE NOT NULL,
    CONSTRAINT unique_email_fullname UNIQUE (email, fullname)
);

-- Employees table
CREATE TABLE employees (
    employee_id TEXT PRIMARY KEY DEFAULT 
        'TCBS' || TO_CHAR(NOW(), 'YYYY') || '-' || LPAD(nextval('employee_id_seq')::text, 4, '0'),
    fullname VARCHAR(100) UNIQUE,
    nickname VARCHAR(50),
    email VARCHAR(100) UNIQUE,
    position VARCHAR(100),
    employment_type VARCHAR(50),
    gender VARCHAR(10),
    contact VARCHAR(20),
    marital_status VARCHAR(20),
    birthday DATE,
    address VARCHAR(150),
    sss_number VARCHAR(20),
    pagibig VARCHAR(20),
    philhealth VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    current_status VARCHAR(20),
    status VARCHAR(20),
    effective_deletion_date DATE,
    deletion_status VARCHAR(20),
    is_restored BOOLEAN DEFAULT FALSE,
    age INT,
    registry_id INT UNIQUE REFERENCES employee_registry(id) ON DELETE CASCADE,
    is_synced BOOLEAN DEFAULT false
);

-- Archive Employees
CREATE TABLE employees_archive (
    employee_id TEXT PRIMARY KEY,
    fullname VARCHAR(100),
    nickname VARCHAR(50),
    email VARCHAR(100),
    position VARCHAR(100),
    employment_type VARCHAR(50),
    gender VARCHAR(10),
    contact VARCHAR(20),
    marital_status VARCHAR(20),
    birthday DATE,
    address VARCHAR(150),
    sss_number VARCHAR(20),
    pagibig VARCHAR(20),
    philhealth VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    current_status VARCHAR(20),
    status VARCHAR(20),
    is_restored BOOLEAN DEFAULT FALSE,
    age INT,
    registry_id INT UNIQUE REFERENCES employee_registry(id) ON DELETE CASCADE,
    CONSTRAINT unique_employee_archive_row UNIQUE(employee_id, fullname, email)
);

-- Employee Contracts
CREATE TABLE employee_contracts (
    contract_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees(employee_id) ON DELETE CASCADE,
    start_of_contract TIMESTAMP,
    end_of_contract TIMESTAMP,
    contract_type TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE employee_contracts_archive (
    contract_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees_archive(employee_id) ON DELETE CASCADE,
    start_of_contract TIMESTAMP,
    end_of_contract TIMESTAMP,
    contract_type TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Employee Documents
CREATE TABLE employee_documents (
	document_id SERIAL PRIMARY KEY,
	employee_id TEXT NOT NULL REFERENCES employees(employee_id) ON DELETE CASCADE,
	document_type VARCHAR(100) NOT NULL,
	link TEXT NOT NULL,
	status VARCHAR(20) DEFAULT 'Pending' CHECK (status IN ('Pending', 'Approved', 'Incomplete')),
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	UNIQUE (employee_id, document_type)
);

CREATE TABLE employee_documents_archive (
    document_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees_archive(employee_id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL,
    link TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'Pending' CHECK (status IN ('Pending', 'Approved', 'Incomplete')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (employee_id, document_type)
);

-- Employee Dependents
CREATE TABLE employee_dependents (
    id SERIAL PRIMARY KEY,
    employee_id TEXT UNIQUE REFERENCES employees(employee_id) ON DELETE CASCADE,
    fullname VARCHAR(100),
    relationship VARCHAR(50),
    address VARCHAR(150),
    contact VARCHAR(20),
    city VARCHAR(50),
    postalcode VARCHAR(10),
    gcash_number VARCHAR(20)
);

CREATE TABLE employee_dependents_archive (
    id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees_archive(employee_id) ON DELETE CASCADE,
    fullname VARCHAR(100),
    relationship VARCHAR(50),
    address VARCHAR(150),
    contact VARCHAR(20),
    city VARCHAR(50),
    postalcode VARCHAR(10),
    gcash_number VARCHAR(20)
);

-- Requests
CREATE TABLE leave_requests (
    request_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees(employee_id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    days INT,
    start_date DATE,
    end_date DATE,
    reason TEXT,
    remarks TEXT DEFAULT '',
    attach_link TEXT,
    status VARCHAR(50) DEFAULT 'Pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE leave_requests_archive (
    request_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees_archive(employee_id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    days INT,
    start_date DATE,
    end_date DATE,
    reason TEXT,
    remarks TEXT DEFAULT '',
    attach_link TEXT,
    status VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE overtime_requests (
    request_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees(employee_id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    date DATE,
    hours DECIMAL(5,2),
    reason TEXT,
    remarks TEXT DEFAULT '',
    attach_link TEXT,
    status VARCHAR(50) DEFAULT 'Pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE overtime_requests_archive (
    request_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees_archive(employee_id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    date DATE,
    hours DECIMAL(5,2),
    reason TEXT,
    remarks TEXT DEFAULT '',
    attach_link TEXT,
    status VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE offset_requests (
    request_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees(employee_id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    date DATE,
    hours DECIMAL(5,2),
    reason TEXT,
    remarks TEXT DEFAULT '',
    attach_link TEXT,
    status VARCHAR(50) DEFAULT 'Pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE offset_requests_archive (
    request_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees_archive(employee_id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    date DATE,
    hours DECIMAL(5,2),
    reason TEXT,
    remarks TEXT DEFAULT '',
    attach_link TEXT,
    status VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


CREATE TABLE employee_notifications (
    employee_id TEXT PRIMARY KEY REFERENCES employees(employee_id) ON DELETE CASCADE,
    count INT DEFAULT 0
);

CREATE TABLE notifications (
    id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees(employee_id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    action VARCHAR(50) NOT NULL,
    message TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Attendance
CREATE TABLE employee_attendance (
    attendance_id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees(employee_id),
    attend_date DATE NOT NULL,
    clock_in TIME NOT NULL,
    clock_out TIME NOT NULL,
    total_hours DECIMAL(5,2) NOT NULL,
    status VARCHAR(100)
);

CREATE TABLE employee_attendance_archive (
    attendance_id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees_archive(employee_id),
    attend_date DATE NOT NULL,
    clock_in TIME NOT NULL,
    clock_out TIME NOT NULL,
    total_hours DECIMAL(5,2) NOT NULL,
    status VARCHAR(100)
);

-- Employee Schedule
CREATE TABLE employee_schedule (
    schedule_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees(employee_id, work_date) ON DELETE CASCADE,
    work_date DATE NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    task VARCHAR(255),
    status VARCHAR(20),
    work_location VARCHAR(50),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Users
CREATE TABLE users (
    account_id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees(employee_id) ON DELETE SET NULL,
    fullname VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password TEXT NOT NULL,
    role VARCHAR(50) NOT NULL,
    must_change_password BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE users_archive (
    account_id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees_archive(employee_id) ON DELETE CASCADE,
    fullname VARCHAR(100) NOT NULL,
    email VARCHAR(100),
    password TEXT,
    role VARCHAR(50) NOT NULL,
    must_change_password BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

-- Audit Logs
CREATE TABLE audit_logs (
    log_id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees(employee_id) ON DELETE CASCADE,
    action VARCHAR(255) NOT NULL,
    action_time TIMESTAMP DEFAULT NOW(),
    remarks TEXT
);

-- Incident Reports
CREATE TABLE incident_reports (
    incident_id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees(employee_id),
    incident_type VARCHAR(100),
    incident_date DATE NOT NULL,
    witness VARCHAR(100),
    reported_by VARCHAR(100),
    description VARCHAR(100),
    status VARCHAR(50)
);

CREATE TABLE incident_reports_archive (
    incident_id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees_archive(employee_id),
    incident_type VARCHAR(100),
    incident_date DATE NOT NULL,
    witness VARCHAR(100),
    reported_by VARCHAR(100),
    description VARCHAR(100),
    status VARCHAR(50)
);

CREATE TABLE employee_deletion_schedule (
    schedule_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees(employee_id) ON DELETE CASCADE,
    deletion_date TIMESTAMP WITH TIME ZONE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'Scheduled', 
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add fingerprint table to your existing schema

-- Fingerprint Registration Table
CREATE TABLE employee_fingerprints (
    fingerprint_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees(employee_id) ON DELETE CASCADE,
    fingerprint_slot INT NOT NULL UNIQUE, -- Arduino sensor slot number (0-127)
    registered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_used TIMESTAMP,
    status VARCHAR(20) DEFAULT 'Active' CHECK (status IN ('Active', 'Inactive', 'Deleted')),
    UNIQUE(employee_id, fingerprint_slot)
);

-- Fingerprint Attendance Log (separate from main attendance)
CREATE TABLE fingerprint_attendance_log (
    log_id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees(employee_id) ON DELETE CASCADE,
    fingerprint_slot INT,
    clock_type VARCHAR(10) CHECK (clock_type IN ('IN', 'OUT')),
    clock_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    device_id VARCHAR(50), -- If you have multiple Arduino devices
    confidence_score INT -- Fingerprint match confidence (0-255)
);

-- Index for faster queries
CREATE INDEX idx_fingerprint_employee ON employee_fingerprints(employee_id);
CREATE INDEX idx_fingerprint_slot ON employee_fingerprints(fingerprint_slot);
CREATE INDEX idx_fp_attendance_employee ON fingerprint_attendance_log(employee_id);
CREATE INDEX idx_fp_attendance_date ON fingerprint_attendance_log(clock_time);

-- Archive table
CREATE TABLE employee_fingerprints_archive (
    fingerprint_id SERIAL PRIMARY KEY,
    employee_id TEXT REFERENCES employees_archive(employee_id) ON DELETE CASCADE,
    fingerprint_slot INT NOT NULL,
    registered_at TIMESTAMP,
    last_used TIMESTAMP,
    status VARCHAR(20)
);

-- Comments
COMMENT ON TABLE employee_fingerprints IS 'Stores fingerprint registration data linked to Arduino sensor slots';
COMMENT ON COLUMN employee_fingerprints.fingerprint_slot IS 'Physical slot number in Arduino fingerprint sensor (0-127 for AS608)';
COMMENT ON TABLE fingerprint_attendance_log IS 'Raw fingerprint clock in/out events before processing into employee_attendance';

ALTER TABLE employee_schedule
ADD CONSTRAINT uniq_employee_day UNIQUE (employee_id, work_date);
-- Add availability_disabled column to employees table
ALTER TABLE employees 
ADD COLUMN IF NOT EXISTS availability_disabled BOOLEAN DEFAULT FALSE;

-- Add comments
COMMENT ON COLUMN employees.availability_disabled IS 'When true, full-time employee will be excluded from auto-scheduling';

-- Update existing employees to have this set to false by default
UPDATE employees SET availability_disabled = FALSE WHERE availability_disabled IS NULL;

-- Add enrollment_type column if it doesn't exist
ALTER TABLE employee_fingerprints 
ADD COLUMN IF NOT EXISTS enrollment_type VARCHAR(20) DEFAULT 'hardware' 
CHECK (enrollment_type IN ('hardware', 'digital', 'hybrid'));

-- Add fingerprint_data column for storing digital templates
ALTER TABLE employee_fingerprints 
ADD COLUMN IF NOT EXISTS fingerprint_data JSONB;


-- Add this to your database schema file or run it separately
-- Drop the table and its indexes
DROP TABLE IF EXISTS password_reset_tokens CASCADE;

-- Now create the new table
CREATE TABLE IF NOT EXISTS password_reset_tokens (
    id SERIAL PRIMARY KEY,
    email VARCHAR(100) NOT NULL UNIQUE,
    token VARCHAR(255) NOT NULL UNIQUE,
    expiry TIMESTAMP NOT NULL,
    user_role VARCHAR(50) NOT NULL DEFAULT 'Admin',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT valid_user_role CHECK (user_role IN ('Admin', 'Head Staff', 'Crew', 'HR'))
);

-- Index for faster token lookups
CREATE INDEX IF NOT EXISTS idx_password_reset_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_password_reset_email ON password_reset_tokens(email);
CREATE INDEX IF NOT EXISTS idx_password_reset_expiry ON password_reset_tokens(expiry);

COMMENT ON TABLE password_reset_tokens IS 'Stores temporary password reset tokens for users';
COMMENT ON COLUMN password_reset_tokens.token IS 'Unique reset token sent via email (32-byte hex)';
COMMENT ON COLUMN password_reset_tokens.expiry IS 'Token expiration timestamp (1 hour from creation)';
COMMENT ON COLUMN password_reset_tokens.user_role IS 'User role requesting password reset';

-- Certificate of Employment Table
CREATE TABLE certificate_requests (
    certificate_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees(employee_id) ON DELETE CASCADE,
    request_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    purpose TEXT NOT NULL, -- Purpose of certificate (e.g., "Bank Loan", "Visa Application")
    status VARCHAR(20) DEFAULT 'Pending' CHECK (status IN ('Pending', 'Approved', 'Rejected')),
    approved_by TEXT REFERENCES users(employee_id) ON DELETE SET NULL, -- Admin/HR who approved
    approved_date TIMESTAMP,
    remarks TEXT, -- Admin/HR notes
    pdf_link TEXT, -- Link to generated PDF (Google Drive or local storage)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Archive table
CREATE TABLE certificate_requests_archive (
    certificate_id SERIAL PRIMARY KEY,
    employee_id TEXT NOT NULL REFERENCES employees_archive(employee_id) ON DELETE CASCADE,
    request_date TIMESTAMP,
    purpose TEXT,
    status VARCHAR(20),
    approved_by TEXT,
    approved_date TIMESTAMP,
    remarks TEXT,
    pdf_link TEXT,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

-- Indexes for faster queries
CREATE INDEX idx_certificate_employee ON certificate_requests(employee_id);
CREATE INDEX idx_certificate_status ON certificate_requests(status);
CREATE INDEX idx_certificate_date ON certificate_requests(request_date DESC);

-- Comments
COMMENT ON TABLE certificate_requests IS 'Stores Certificate of Employment requests from employees';
COMMENT ON COLUMN certificate_requests.purpose IS 'Reason for requesting the certificate';
COMMENT ON COLUMN certificate_requests.approved_by IS 'Employee ID of admin/HR who approved';
COMMENT ON COLUMN certificate_requests.pdf_link IS 'Link to the generated PDF certificate';